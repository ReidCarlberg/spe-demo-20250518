import { useState, useEffect, useRef } from 'react';
import { useNavigate, useParams, Link } from 'react-router-dom';
import { useAuth } from '../AuthContext';
import { speService } from '../speService';
import FilePreview from '../components/FilePreview';
import PersistentChatPanel from '../components/PersistentChatPanel';
import './FileBrowserPage.css';

// Icons for different file types
const FileIcon = ({ type }) => {
  let iconClass = "file-icon";
  
  switch (type) {
    case 'folder':
      iconClass += " folder-icon";
      return <span className={iconClass}><i className="fas fa-folder"></i></span>;
    case 'pdf':
      iconClass += " pdf-icon";
      return <span className={iconClass}><i className="fas fa-file-pdf"></i></span>;
    case 'word':
    case 'docx':
    case 'doc':
      iconClass += " word-icon";
      return <span className={iconClass}><i className="fas fa-file-word"></i></span>;
    case 'excel':
    case 'xlsx':
    case 'xls':
      iconClass += " excel-icon";
      return <span className={iconClass}><i className="fas fa-file-excel"></i></span>;
    case 'powerpoint':
    case 'pptx':
    case 'ppt':
      iconClass += " powerpoint-icon";
      return <span className={iconClass}><i className="fas fa-file-powerpoint"></i></span>;
    case 'image':
    case 'png':
    case 'jpg':
    case 'jpeg':
    case 'gif':
      iconClass += " image-icon";
      return <span className={iconClass}><i className="fas fa-file-image"></i></span>;
    case 'text':
    case 'txt':
      iconClass += " text-icon";
      return <span className={iconClass}><i className="fas fa-file-alt"></i></span>;
    default:
      return <span className={iconClass}><i className="fas fa-file"></i></span>;
  }
};

const FileBrowserPage = () => {
  const { isAuthenticated, loading } = useAuth();
  const navigate = useNavigate();
  const { containerId, folderId } = useParams();
  const [files, setFiles] = useState([]);
  const [container, setContainer] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentPath, setCurrentPath] = useState([]);
  const [currentFolderId, setCurrentFolderId] = useState(folderId || 'root');
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const fileInputRef = useRef(null);
  const [previewFile, setPreviewFile] = useState(null);
  const [chatError, setChatError] = useState(false);
  const [isChatCollapsed, setIsChatCollapsed] = useState(window.innerWidth <= 768);

  useEffect(() => {
    // Redirect to login if not authenticated
    if (!isAuthenticated && !loading) {
      navigate('/login');
    }
  }, [isAuthenticated, navigate, loading]);

  // Reset chat error on component mount or container change
  useEffect(() => {
    if (containerId) {
      setChatError(false);
    }
  }, [containerId]);
  
  // Handle responsive chat panel
  useEffect(() => {
    const handleResize = () => {
      setIsChatCollapsed(window.innerWidth <= 768);
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  // Fetch container details when component mounts
  useEffect(() => {
    if (containerId && isAuthenticated) {
      const fetchContainerDetails = async () => {
        try {
          // Get all containers and find the one with matching ID
          const containers = await speService.getContainers();
          const containerMatch = containers.find(c => c.id === containerId);
          
          if (containerMatch) {
            setContainer(containerMatch);
            
            // Initialize the path with container name
            if (currentPath.length === 0) {
              setCurrentPath([{ name: 'Home', id: 'root' }, { name: containerMatch.displayName, id: 'root' }]);
            }
          } else {
            setError('Container not found');
          }
        } catch (error) {
          console.error('Error fetching container details:', error);
          setError('Failed to load container details: ' + error.message);
        }
      };
      
      fetchContainerDetails();
    }
  }, [containerId, isAuthenticated, currentPath.length]);

  // Fetch files when component mounts or folder changes
  useEffect(() => {
    if (containerId && isAuthenticated && container) {
      fetchFiles(currentFolderId);
    }
  }, [containerId, isAuthenticated, container, currentFolderId]);

  const fetchFiles = async (folderId) => {
    setIsLoading(true);
    try {
      const data = await speService.listFiles(containerId, folderId);
      setFiles(data);
      setError(null);
    } catch (error) {
      console.error('Error fetching files:', error);
      setError('Failed to load files: ' + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const navigateToFolder = async (folder) => {
    try {
      // Update the current folder ID
      setCurrentFolderId(folder.id);
      
      // Update the path
      if (folder.id === 'root') {
        // Reset to the root path
        setCurrentPath([{ name: 'Home', id: 'root' }, { name: container.displayName, id: 'root' }]);
      } else {
        // Add the new folder to the path
        const newPath = [...currentPath];
        
        // If the folder is already in the path, trim the path to that point
        const existingIndex = newPath.findIndex(item => item.id === folder.id);
        
        if (existingIndex >= 0) {
          setCurrentPath(newPath.slice(0, existingIndex + 1));
        } else {
          // Otherwise add the folder to the path
          setCurrentPath([...newPath, { name: folder.name, id: folder.id }]);
        }
      }
    } catch (error) {
      console.error('Error navigating to folder:', error);
      setError('Failed to navigate to folder: ' + error.message);
    }
  };

  const getFileTypeFromMime = (mimeType, name) => {
    if (!mimeType) {
      // Try to get type from extension
      const extension = name.split('.').pop().toLowerCase();
      
      switch (extension) {
        case 'pdf': return 'pdf';
        case 'doc': case 'docx': return 'word';
        case 'xls': case 'xlsx': return 'excel';
        case 'ppt': case 'pptx': return 'powerpoint';
        case 'jpg': case 'jpeg': case 'png': case 'gif': return 'image';
        case 'txt': return 'text';
        default: return 'file';
      }
    }
    
    if (mimeType.includes('folder')) return 'folder';
    if (mimeType.includes('pdf')) return 'pdf';
    if (mimeType.includes('word')) return 'word';
    if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'excel';
    if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'powerpoint';
    if (mimeType.includes('image')) return 'image';
    if (mimeType.includes('text')) return 'text';
    
    return 'file';
  };

  const handleFileClick = (file) => {
    if (file.folder) {
      navigateToFolder(file);
    } else {
      // Handle file preview or open
      console.log('Open file', file);
      // For now, just open the file in a new tab if it has a webUrl
      if (file.webUrl) {
        window.open(file.webUrl, '_blank');
      }
    }
  };
  
  const handlePreviewClick = async (event, file) => {
    event.stopPropagation(); // Prevent parent click event
    
    try {
      // Only handle non-Office files like PDF, JPEG, etc.
      if (file.id && containerId) {
        setIsLoading(true);
        // Get the preview URL from the SPE service
        const previewUrl = await speService.getFilePreviewUrl(containerId, file.id);
        
        setPreviewFile({
          url: previewUrl,
          name: file.name
        });
        setIsLoading(false);
      }
    } catch (error) {
      console.error('Error getting preview URL:', error);
      setError(`Failed to get preview URL: ${error.message}`);
      setIsLoading(false);
    }
  };
  
  const closePreview = () => {
    setPreviewFile(null);
  };
  
  const isPreviewableFile = (file) => {
    if (!file || file.folder) return false;
    
    const fileExtension = file.name?.split('.').pop()?.toLowerCase();
    const previewableExtensions = ['pdf', 'jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'tiff', 'webp'];
    
    // Check if it's a known previewable type
    return previewableExtensions.includes(fileExtension) || 
           (file.file?.mimeType && (
             file.file.mimeType.startsWith('image/') || 
             file.file.mimeType === 'application/pdf'
           ));
  };
  
  const isOfficeFile = (file) => {
    if (!file || file.folder) return false;
    
    const fileExtension = file.name?.split('.').pop()?.toLowerCase();
    const officeExtensions = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'];
    
    return officeExtensions.includes(fileExtension) || 
           (file.file?.mimeType && (
             file.file.mimeType.includes('word') || 
             file.file.mimeType.includes('excel') || 
             file.file.mimeType.includes('powerpoint') || 
             file.file.mimeType.includes('spreadsheet') || 
             file.file.mimeType.includes('presentation')
           ));
  };
  
  const handleDownloadClick = async (event, file) => {
    event.stopPropagation(); // Prevent parent click event
    
    try {
      if (!file || !file.id) {
        throw new Error('Invalid file information');
      }
      
      // If the file has a direct download URL, use it
      if (file.webUrl) {
        const downloadURL = file.webUrl;
        // Create a hidden anchor element for download
        const downloadLink = document.createElement('a');
        downloadLink.href = downloadURL;
        downloadLink.download = file.name; // Set the filename
        downloadLink.target = '_blank';
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      } else {
        // Fallback - you would need to implement a method to fetch the file content
        console.log('Download URL not available for this file');
      }
    } catch (error) {
      console.error('Error downloading file:', error);
      setError(`Failed to download file: ${error.message}`);
    }
  };
  
  const handlePathClick = (pathItem, index) => {
    if (index === 0) {
      // Clicking on "Home" should navigate back to the containers list
      navigate('/spe-explore');
    } else {
      // Otherwise navigate to the selected folder in the path
      navigateToFolder({ id: pathItem.id, name: pathItem.name });
      // Trim the path to this point
      setCurrentPath(currentPath.slice(0, index + 1));
    }
  };

  const handleFileUpload = (event) => {
    const files = event.target.files;
    if (files.length === 0) return;
    
    uploadFiles(files);
  };
  
  const handleDragOver = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  
  const handleDrop = (event) => {
    event.preventDefault();
    event.stopPropagation();
    
    const files = event.dataTransfer.files;
    if (files.length === 0) return;
    
    uploadFiles(files);
  };
  
  const uploadFiles = async (files) => {
    if (!containerId || !currentFolderId) {
      setError('Container or folder not specified');
      return;
    }
    
    setIsUploading(true);
    setError(null);
    
    try {
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Report progress based on file count
        setUploadProgress((i / files.length) * 100);
        
        await speService.uploadFile(
          containerId,
          currentFolderId,
          file,
          (progress) => {
            // Calculate overall progress including previous files
            const overallProgress = ((i + progress) / files.length) * 100;
            setUploadProgress(overallProgress);
          }
        );
      }
      
      // Upload complete
      setUploadProgress(100);
      
      // Refresh the file list
      await fetchFiles(currentFolderId);
    } catch (error) {
      console.error('Upload failed:', error);
      setError('File upload failed: ' + error.message);
    } finally {
      setIsUploading(false);
      // Reset the file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };
  
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };
  
  // Toggle chat panel collapsed state
  const toggleChatCollapsed = () => {
    setIsChatCollapsed(prev => !prev);
  };
  
  // Handle chat errors  
  const handleChatError = () => {
    setChatError(true);
  };
  
  // If still loading or not authenticated, show loading
  if (loading || !isAuthenticated) {
    return (
      <div className="file-browser-loading">
        <p>Loading file browser...</p>
      </div>
    );
  }

  return (
    <div className={`file-browser-wrapper ${containerId ? 'with-chat-panel' : ''} ${isChatCollapsed ? 'panel-collapsed' : ''}`}>
      <div className="file-browser-container">
        <div className="file-browser-header">
          <div className="file-browser-title">
            <h1>File Browser</h1>
            <p className="file-browser-subtitle">
              {container ? container.displayName : 'Loading container...'}
            </p>
          </div>
        </div>

        {error && (
          <div className="file-browser-error">
            <p>{error}</p>
          </div>
        )}

        <div className="file-browser-path">
          {currentPath.map((pathItem, index) => (
            <span key={index}>
              <span 
                className="path-item" 
                onClick={() => handlePathClick(pathItem, index)}
              >
                {pathItem.name}
              </span>
              {index < currentPath.length - 1 && <span className="path-separator"> &gt; </span>}
            </span>
          ))}
        </div>
        
        <div className="file-browser-actions">
          <button 
            className="file-browser-button refresh-button" 
            onClick={() => fetchFiles(currentFolderId)}
            disabled={isLoading}
          >
            {isLoading ? 'Loading...' : 'Refresh Files'}
          </button>
          <button
            className="file-browser-button upload-button"
            onClick={triggerFileInput}
            disabled={isUploading}
          >
            {isUploading ? 'Uploading...' : 'Upload Files'}
          </button>
          <input 
            type="file" 
            ref={fileInputRef}
            style={{ display: 'none' }} 
            onChange={handleFileUpload}
            multiple
          />
          <Link to="/spe-explore" className="file-browser-button back-button">
            Back to Containers
          </Link>
        </div>

        {isUploading && (
          <div className="upload-progress-container">
            <div 
              className="upload-progress-bar" 
              style={{ width: `${uploadProgress}%` }}
            ></div>
            <div className="upload-progress-text">
              Uploading: {Math.round(uploadProgress)}%
            </div>
          </div>
        )}
        
        <div className="files-section">
          {isLoading ? (
            <p className="loading-text">Loading files...</p>
          ) : files.length === 0 ? (
            <div 
              className="empty-state drop-zone" 
              onDragOver={handleDragOver} 
              onDrop={handleDrop}
            >
              <p>This folder is empty.</p>
              <p className="drop-instructions">Drop files here to upload or use the Upload button above.</p>
            </div>
          ) : (
            <div 
              className="files-list"
              onDragOver={handleDragOver} 
              onDrop={handleDrop}
            >
              {files.map(file => {
                const fileType = file.folder ? 'folder' : getFileTypeFromMime(file.file?.mimeType, file.name);
                
                return (
                  <div 
                    className="file-item" 
                    key={file.id}
                    onClick={() => handleFileClick(file)}
                  >
                    <div className="file-icon-container">
                      <FileIcon type={fileType} />
                    </div>
                    <div className="file-details">
                      <div className="file-name">{file.name}</div>
                      <div className="file-meta">
                        {!file.folder && <span className="file-size">{file.size ? `${Math.round(file.size / 1024)} KB` : 'Unknown size'}</span>}
                        {file.lastModifiedDateTime && (
                          <span className="file-date">
                            Modified: {new Date(file.lastModifiedDateTime).toLocaleString()}
                          </span>
                        )}
                      </div>
                    </div>
                    
                    <div className="file-actions">
                      {file.folder ? (
                        <button className="file-action-button" onClick={(e) => { e.stopPropagation(); navigateToFolder(file); }}>
                          <i className="fas fa-folder-open"></i>
                        </button>
                      ) : (
                        <>
                          {isPreviewableFile(file) && !isOfficeFile(file) && (
                            <button 
                              className="file-action-button preview-button" 
                              onClick={(e) => handlePreviewClick(e, file)}
                              title={`Preview ${file.name}`}
                            >
                              <i className="fas fa-eye"></i>
                              <span className="file-action-text">Preview</span>
                            </button>
                          )}
                          <button 
                            className="file-action-button" 
                            onClick={(e) => handleDownloadClick(e, file)}
                            title="Download file"
                          >
                            <i className="fas fa-download"></i>
                          </button>
                        </>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
        
        {/* Document Preview */}
        {previewFile && (
          <FilePreview 
            fileUrl={previewFile.url}
            fileName={previewFile.name}
            onClose={closePreview}
          />
        )}
      </div>
      
      {/* Persistent Chat Panel */}
      {containerId && (
        <PersistentChatPanel
          containerId={containerId}
          containerName={container?.displayName || "My Container"}
          collapsed={isChatCollapsed}
          onToggleCollapse={toggleChatCollapsed}
          onError={handleChatError}
        />
      )}
    </div>
  );
};

export default FileBrowserPage;
